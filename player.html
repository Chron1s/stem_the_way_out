<!DOCTYPE html>
<html>
<head>
  <title>SIGNAL - Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }

    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    body {
      background: #0a0a0a;
      color: #fff;
      font-family: 'Space Mono', monospace;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      overflow: hidden;
    }

    /* Header */
    .header {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px 20px;
      border-bottom: 1px solid #1a1a1a;
      position: relative;
      flex-shrink: 0;
    }

    .back-btn {
      position: absolute;
      left: 15px;
      color: #555;
      font-size: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 6px 12px;
      border: 1px solid #333;
      border-radius: 15px;
      background: transparent;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
    }

    .track-title {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
    }

    /* Main Player Area - perfectly centered */
    .player-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
    }

    /* Stem Control Grid - symmetrical cross pattern */
    .stem-grid {
      display: grid;
      grid-template-columns: 100px 60px 100px;
      grid-template-rows: 100px 60px 100px;
      gap: 5px;
      align-items: center;
      justify-items: center;
    }

    .stem-control {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .stem-control.horizontal {
      flex-direction: row;
      gap: 6px;
    }

    .stem-control.top { grid-column: 2; grid-row: 1; }
    .stem-control.left { grid-column: 1; grid-row: 2; }
    .stem-control.center { grid-column: 2; grid-row: 2; }
    .stem-control.right { grid-column: 3; grid-row: 2; }
    .stem-control.bottom { grid-column: 2; grid-row: 3; }

    .stem-label {
      font-size: 8px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #555;
    }

    /* Light Bar Slider - no borders */
    .light-bar {
      display: flex;
      gap: 5px;
      padding: 8px;
      background: rgba(15, 15, 15, 0.8);
      border-radius: 20px;
      cursor: pointer;
      touch-action: none;
    }

    .light-bar.horizontal {
      width: 85px;
      height: 30px;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      padding: 5px 8px;
    }

    .stem-control.left .light-bar.horizontal {
      flex-direction: row-reverse;
    }

    .light-bar.vertical {
      width: 30px;
      height: 85px;
      flex-direction: column-reverse;
      align-items: center;
      justify-content: center;
      padding: 8px 5px;
    }

    .stem-control.bottom .light-bar.vertical {
      flex-direction: column;
    }

    /* LED Orbs - clean, no borders or outlines */
    .led-segment {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #1a1a1a;
      flex-shrink: 0;
      transition: opacity 0.1s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }

    .led-segment.active {
      opacity: 1;
    }

    .stem-control[data-stem="drums"] .led-segment.active {
      background: #2e86de;
      box-shadow: 0 0 6px #2e86de;
    }

    .stem-control[data-stem="bass"] .led-segment.active {
      background: #1a5276;
      box-shadow: 0 0 6px #1a5276;
    }

    .stem-control[data-stem="other"] .led-segment.active {
      background: #5dade2;
      box-shadow: 0 0 6px #5dade2;
    }

    .stem-control[data-stem="vocals"] .led-segment.active {
      background: #85c1e9;
      box-shadow: 0 0 6px #85c1e9;
    }

    /* Smooth pulse animation */
    .led-segment.active.pulsing {
      animation: smoothPulse 0.3s ease-out;
    }

    @keyframes smoothPulse {
      0% { transform: scale(1.3); opacity: 1; }
      50% { transform: scale(1.15); opacity: 0.9; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Play Button */
    .play-button {
      width: 54px;
      height: 54px;
      border-radius: 50%;
      background: #111;
      border: 2px solid #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .play-icon {
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 8px 0 8px 14px;
      border-color: transparent transparent transparent #fff;
      margin-left: 3px;
    }

    .play-button.playing .play-icon {
      border: none;
      width: 14px;
      height: 14px;
      margin-left: 0;
      background: linear-gradient(to right, #fff 0%, #fff 35%, transparent 35%, transparent 65%, #fff 65%, #fff 100%);
    }

    /* Progress Section - centered */
    .progress-section {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 0;
      flex-shrink: 0;
    }

    .time-row {
      width: 220px;
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .time-text {
      font-size: 10px;
      color: #555;
      font-family: 'Space Mono', monospace;
      min-width: 35px;
    }

    .time-text:last-child {
      text-align: right;
    }

    .progress-bar {
      width: 220px;
      height: 3px;
      background: #222;
      border-radius: 2px;
      cursor: pointer;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #85c1e9);
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s linear;
    }

    .skip-controls {
      display: flex;
      justify-content: center;
      gap: 25px;
      margin-top: 12px;
    }

    .skip-btn {
      width: 26px;
      height: 26px;
      background: transparent;
      border: 1px solid #333;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #555;
    }

    .skip-btn svg {
      width: 10px;
      height: 10px;
      fill: currentColor;
    }

    /* Loading */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .loading-overlay.hidden {
      display: none;
    }

    .loading-text {
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #555;
      margin-bottom: 15px;
    }

    .loading-bar {
      width: 150px;
      height: 2px;
      background: #222;
      overflow: hidden;
    }

    .loading-progress {
      height: 100%;
      background: #fff;
      width: 0%;
    }

    /* Safe areas for iPhone */
    @supports (padding-top: env(safe-area-inset-top)) {
      .header { padding-top: calc(15px + env(safe-area-inset-top)); }
      .progress-section { padding-bottom: calc(20px + env(safe-area-inset-bottom)); }
    }
  </style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
  <div class="loading-text">Loading Stems</div>
  <div class="loading-bar">
    <div class="loading-progress" id="loadingProgress"></div>
  </div>
</div>

<div class="header">
  <button onclick="window.location.href='index.html'" class="back-btn">Tracks</button>
  <div class="track-title" id="trackTitle">Loading...</div>
</div>

<div class="player-container">
  <div class="stem-grid">
    <div class="stem-control top" data-stem="vocals">
      <span class="stem-label">Vocals</span>
      <div class="light-bar vertical">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
    </div>

    <div class="stem-control left horizontal" data-stem="other">
      <span class="stem-label">Other</span>
      <div class="light-bar horizontal">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
    </div>

    <div class="stem-control center">
      <div class="play-button" id="playButton">
        <div class="play-icon"></div>
      </div>
    </div>

    <div class="stem-control right horizontal" data-stem="drums">
      <div class="light-bar horizontal">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
      <span class="stem-label">Drums</span>
    </div>

    <div class="stem-control bottom" data-stem="bass">
      <div class="light-bar vertical">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
      <span class="stem-label">Bass</span>
    </div>
  </div>
</div>

<div class="progress-section">
  <div class="time-row">
    <span class="time-text" id="currentTime">0:00</span>
    <span class="time-text" id="totalTime">0:00</span>
  </div>
  <div class="progress-bar" id="progressBar">
    <div class="progress-fill" id="progressFill"></div>
  </div>
  <div class="skip-controls">
    <button class="skip-btn" id="skipBack">
      <svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>
    </button>
    <button class="skip-btn" id="skipForward">
      <svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
    </button>
  </div>
</div>

<audio id="silentAudio" src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAAYYoRwmHAAAAAAD/+1DEAAAGAAGn9AAAIwAANP8AAABM" loop playsinline></audio>

<script>
  function unlockAudio() {
    const silentAudio = document.getElementById('silentAudio');
    silentAudio.play().catch(() => {});
    silentAudio.pause();
    silentAudio.currentTime = 0;
    
    if (window.audioContextUnlocked) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      const ctx = new AudioContext();
      const buffer = ctx.createBuffer(1, 1, 22050);
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.connect(ctx.destination);
      source.start(0);
      if (ctx.state === 'suspended') ctx.resume();
      window.audioContextUnlocked = true;
    }
  }

  document.body.addEventListener('touchstart', unlockAudio, { once: true });
  document.body.addEventListener('click', unlockAudio, { once: true });

  class StemPlayer {
    constructor() {
      this.audioContext = null;
      this.isPlaying = false;
      this.startTime = 0;
      this.pauseTime = 0;
      this.duration = 0;
      this.stems = {
        vocals: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastPulseTime: 0, lastRms: 0 },
        drums: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastPulseTime: 0, lastRms: 0 },
        bass: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastPulseTime: 0, lastRms: 0 },
        other: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastPulseTime: 0, lastRms: 0 }
      };
      this.masterGain = null;
      this.loadingProgress = document.getElementById('loadingProgress');
      this.loadingOverlay = document.getElementById('loadingOverlay');
      this.progressBar = document.getElementById('progressBar');
      this.progressFill = document.getElementById('progressFill');
      this.currentTimeEl = document.getElementById('currentTime');
      this.totalTimeEl = document.getElementById('totalTime');
      this.init();
    }

    initAudioContext() {
      if (this.audioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      this.audioContext = new AudioContext();
      this.masterGain = this.audioContext.createGain();
      this.masterGain.connect(this.audioContext.destination);
      if (this.audioContext.state === 'suspended') this.audioContext.resume();
    }

    async init() {
      try {
        this.initAudioContext();
        await this.loadStems();
        this.setupUI();
        this.setupProgressBar();
        this.setupSkipControls();
        Object.keys(this.stems).forEach(stem => updateLightBar(stem, 100));
        for (const stem of Object.values(this.stems)) {
          if (stem.buffer) {
            this.duration = stem.buffer.duration;
            this.totalTimeEl.textContent = this.formatTime(this.duration);
            break;
          }
        }
        this.updateProgress();
        this.loadingOverlay.classList.add('hidden');
      } catch (e) {
        console.log('Waiting for user interaction');
      }
    }

    async loadStems() {
      if (!this.audioContext) return;
      const stemsToLoad = Object.entries(TRACK_CONFIG.stems).filter(([_, stem]) => stem !== null);
      const totalStems = stemsToLoad.length;
      let loaded = 0;

      const loadPromises = stemsToLoad.map(async ([stemName, stemData]) => {
        if (stemData && stemData.file) {
          try {
            const response = await fetch(stemData.file);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            const gainNode = this.audioContext.createGain();
            const analyser = this.audioContext.createAnalyser();
            analyser.fftSize = 512;
            analyser.smoothingTimeConstant = 0.4;
            gainNode.connect(analyser);
            analyser.connect(this.masterGain);
            this.stems[stemName].buffer = audioBuffer;
            this.stems[stemName].gainNode = gainNode;
            this.stems[stemName].analyser = analyser;
            loaded++;
            this.loadingProgress.style.width = (loaded / totalStems * 100) + '%';
            return true;
          } catch (error) {
            console.error(`Failed to load ${stemName}:`, error);
            return false;
          }
        }
        return false;
      });

      await Promise.all(loadPromises);
    }

    setupUI() {
      document.getElementById('playButton').addEventListener('click', () => {
        unlockAudio();
        this.initAudioContext();
        if (this.audioContext.state === 'suspended') this.audioContext.resume();
        this.togglePlay();
      });

      document.querySelectorAll('.stem-control[data-stem]').forEach(control => {
        const stemName = control.dataset.stem;
        const slider = control.querySelector('.light-bar');
        const isHorizontal = slider.classList.contains('horizontal');
        const isLeftSlider = control.classList.contains('left');
        let isDragging = false;
        let dragStarted = false;

        const updateVolume = (percent) => {
          percent = Math.max(0, Math.min(100, percent));
          this.stems[stemName].volume = percent;
          updateLightBar(stemName, percent);
          if (this.stems[stemName].gainNode) {
            this.stems[stemName].gainNode.gain.setTargetAtTime(percent / 100, this.audioContext.currentTime, 0.02);
          }
        };

        const handleMove = (clientX, clientY) => {
          const rect = slider.getBoundingClientRect();
          let percent;
          if (isHorizontal) {
            percent = isLeftSlider ? 100 - ((clientX - rect.left) / rect.width) * 100 : ((clientX - rect.left) / rect.width) * 100;
          } else {
            const isBottomSlider = control.classList.contains('bottom');
            percent = isBottomSlider ? ((clientY - rect.top) / rect.height) * 100 : 100 - ((clientY - rect.top) / rect.height) * 100;
          }
          updateVolume(percent);
        };

        const soloStem = () => {
          const allMuted = Object.entries(this.stems).filter(([n]) => n !== stemName).every(([, s]) => s.volume === 0);
          const thisFull = this.stems[stemName].volume === 100;
          if (allMuted && thisFull) {
            Object.keys(this.stems).forEach(name => {
              this.stems[name].volume = 100;
              if (this.stems[name].gainNode) this.stems[name].gainNode.gain.setTargetAtTime(1, this.audioContext.currentTime, 0.02);
              updateLightBar(name, 100);
            });
          } else {
            Object.keys(this.stems).forEach(name => {
              const vol = name === stemName ? 100 : 0;
              this.stems[name].volume = vol;
              if (this.stems[name].gainNode) this.stems[name].gainNode.gain.setTargetAtTime(vol / 100, this.audioContext.currentTime, 0.02);
              updateLightBar(name, vol);
            });
          }
        };

        slider.addEventListener('mousedown', (e) => { e.preventDefault(); isDragging = true; dragStarted = false; });
        document.addEventListener('mousemove', (e) => { if (isDragging) { dragStarted = true; handleMove(e.clientX, e.clientY); } });
        document.addEventListener('mouseup', () => { if (isDragging && !dragStarted) soloStem(); isDragging = false; });
        slider.addEventListener('touchstart', (e) => { e.preventDefault(); isDragging = true; dragStarted = false; }, { passive: false });
        slider.addEventListener('touchmove', (e) => { if (isDragging) { dragStarted = true; handleMove(e.touches[0].clientX, e.touches[0].clientY); } }, { passive: false });
        slider.addEventListener('touchend', () => { if (isDragging && !dragStarted) soloStem(); isDragging = false; });
      });
    }

    setupProgressBar() {
      let isDragging = false;
      const seek = (clientX) => {
        const rect = this.progressBar.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        this.seekTo(percent * this.duration);
      };
      this.progressBar.addEventListener('mousedown', (e) => { isDragging = true; seek(e.clientX); });
      document.addEventListener('mousemove', (e) => { if (isDragging) seek(e.clientX); });
      document.addEventListener('mouseup', () => { isDragging = false; });
      this.progressBar.addEventListener('touchstart', (e) => { isDragging = true; seek(e.touches[0].clientX); }, { passive: true });
      this.progressBar.addEventListener('touchmove', (e) => { if (isDragging) seek(e.touches[0].clientX); }, { passive: true });
      this.progressBar.addEventListener('touchend', () => { isDragging = false; });
    }

    setupSkipControls() {
      document.getElementById('skipBack').addEventListener('click', () => this.seekTo(Math.max(0, this.getCurrentTime() - 10)));
      document.getElementById('skipForward').addEventListener('click', () => this.seekTo(Math.min(this.duration, this.getCurrentTime() + 10)));
    }

    getCurrentTime() {
      if (!this.audioContext) return 0;
      return this.isPlaying ? this.audioContext.currentTime - this.startTime : this.pauseTime;
    }

    seekTo(time) {
      if (!this.audioContext) return;
      time = Math.max(0, Math.min(time, this.duration));
      if (this.isPlaying) {
        Object.values(this.stems).forEach(stem => { if (stem.source) { stem.source.stop(); stem.source = null; } });
        this.startTime = this.audioContext.currentTime - time;
        Object.entries(this.stems).forEach(([_, stem]) => {
          if (stem.buffer) {
            const source = this.audioContext.createBufferSource();
            source.buffer = stem.buffer;
            source.connect(stem.gainNode);
            source.start(0, time);
            stem.source = source;
          }
        });
      } else {
        this.pauseTime = time;
      }
      this.progressFill.style.width = (time / this.duration) * 100 + '%';
      this.currentTimeEl.textContent = this.formatTime(time);
    }

    togglePlay() { if (this.isPlaying) this.pause(); else this.play(); }

    play() {
      if (this.isPlaying || !this.audioContext) return;
      if (this.audioContext.state === 'suspended') this.audioContext.resume();
      const offset = this.pauseTime;
      this.startTime = this.audioContext.currentTime - offset;
      Object.entries(this.stems).forEach(([_, stem]) => {
        if (stem.buffer) {
          const source = this.audioContext.createBufferSource();
          source.buffer = stem.buffer;
          source.connect(stem.gainNode);
          source.start(0, offset);
          stem.source = source;
          stem.gainNode.gain.value = stem.volume / 100;
        }
      });
      this.isPlaying = true;
      document.getElementById('playButton').classList.add('playing');
    }

    pause() {
      if (!this.isPlaying) return;
      this.pauseTime = this.audioContext.currentTime - this.startTime;
      Object.values(this.stems).forEach(stem => { if (stem.source) { stem.source.stop(); stem.source = null; } });
      this.isPlaying = false;
      document.getElementById('playButton').classList.remove('playing');
    }

    stop() {
      this.pause();
      this.pauseTime = 0;
      this.progressFill.style.width = '0%';
      this.currentTimeEl.textContent = '0:00';
    }

    updateProgress() {
      const update = () => {
        if (this.isPlaying && this.audioContext) {
          const currentTime = this.getCurrentTime();
          this.progressFill.style.width = Math.min((currentTime / this.duration) * 100, 100) + '%';
          this.currentTimeEl.textContent = this.formatTime(currentTime);
          if (currentTime >= this.duration) this.stop();
          this.updateRhythmicPulse();
        }
        requestAnimationFrame(update);
      };
      update();
    }

    updateRhythmicPulse() {
      const now = Date.now();
      
      Object.entries(this.stems).forEach(([stemName, stem]) => {
        if (stem.analyser && stem.volume > 0 && stem.buffer) {
          const dataArray = new Uint8Array(stem.analyser.frequencyBinCount);
          stem.analyser.getByteFrequencyData(dataArray);
          
          // Calculate RMS with frequency weighting
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i] * dataArray[i];
          }
          const rms = Math.sqrt(sum / dataArray.length);
          
          // Detect significant increase (attack detection)
          const rmsIncrease = rms - stem.lastRms;
          stem.lastRms = rms * 0.7 + stem.lastRms * 0.3; // Smooth the RMS
          
          // Lower thresholds for more sensitivity
          let threshold = 25;
          let attackThreshold = 8;
          
          if (stemName === 'drums') {
            threshold = 30;
            attackThreshold = 12;
          } else if (stemName === 'bass') {
            threshold = 20;
            attackThreshold = 6;
          } else if (stemName === 'vocals') {
            threshold = 18;
            attackThreshold = 5;
          } else {
            threshold = 18;
            attackThreshold = 5;
          }
          
          // Longer cooldown for smoother animation
          const cooldown = 180;
          
          const control = document.querySelector(`.stem-control[data-stem="${stemName}"]`);
          if (control && (rms > threshold || rmsIncrease > attackThreshold) && (now - stem.lastPulseTime) > cooldown) {
            stem.lastPulseTime = now;
            control.querySelectorAll('.led-segment.active').forEach(seg => {
              seg.classList.remove('pulsing');
              void seg.offsetWidth; // Force reflow
              seg.classList.add('pulsing');
            });
          }
        }
      });
    }

    formatTime(seconds) {
      if (!seconds || isNaN(seconds) || !isFinite(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
  }

  function updateLightBar(stemName, volume) {
    const control = document.querySelector(`.stem-control[data-stem="${stemName}"]`);
    if (!control) return;
    const segments = control.querySelectorAll('.led-segment');
    const activeCount = Math.round((volume / 100) * segments.length);
    segments.forEach((seg, i) => {
      if (i < activeCount) seg.classList.add('active');
      else seg.classList.remove('active');
    });
  }

  const TRACKS = {
    'script': { name: 'Script (Intro)', stems: { vocals: { file: 'audio/01_SC_Instruments.mp3', label: 'Instruments' }, drums: { file: 'audio/01_SC_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/01_SC_Bass.mp3', label: 'Bass' }, other: { file: 'audio/01_SC_Other.mp3', label: 'Other' } } },
    'neon': { name: 'Neon', stems: { vocals: { file: 'audio/02_NE_Instruments.mp3', label: 'Instruments' }, drums: { file: 'audio/02_NE_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/02_NE_Bass.mp3', label: 'Bass' }, other: { file: 'audio/02_NE_Other.mp3', label: 'Other' } } },
    'smoke-show': { name: 'Smoke Show', stems: { vocals: { file: 'audio/03_SMS_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/03_SMS_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/03_SMS_Bass.mp3', label: 'Bass' }, other: { file: 'audio/03_SMS_Other.mp3', label: 'Other' } } },
    'godless-idols': { name: 'Godless Idols', stems: { vocals: { file: 'audio/GI_Voice.mp3', label: 'Voice' }, drums: { file: 'audio/GI_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/GI_Bass.mp3', label: 'Bass' }, other: { file: 'audio/GI_Other.mp3', label: 'Other' } } },
    'printer-brain': { name: 'Printer Brain', stems: { vocals: { file: 'audio/05_PB_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/05_PB_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/05_PB_Bass.mp3', label: 'Bass' }, other: { file: 'audio/05_PB_Other.mp3', label: 'Other' } } },
    'ash-and-gold': { name: 'Ash and Gold', stems: { vocals: { file: 'audio/06_AG_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/06_AG_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/06_AG_Instruments.mp3', label: 'Instruments' }, other: { file: 'audio/06_AG_Other.mp3', label: 'Other' } } },
    'production-line': { name: 'Production Line', stems: { vocals: { file: 'audio/07_PL_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/07_PL_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/07_PL_Bass.mp3', label: 'Bass' }, other: { file: 'audio/07_PL_Other.mp3', label: 'Other' } } },
    'byd3s1gn': { name: 'ByD3s1Gn', stems: { vocals: { file: 'audio/08_BD_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/08_BD_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/08_BD_Bass.mp3', label: 'Bass' }, other: { file: 'audio/08_BD_Instruments.mp3', label: 'Instruments' } } },
    'youre-meant-to-forget-this': { name: "You're Meant to Forget This", stems: { vocals: { file: 'audio/09_YAMTFT_Instrument.mp3', label: 'Instrument' }, drums: { file: 'audio/09_YAMTFT_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/09_YAMTFT_Bass.mp3', label: 'Bass' }, other: null } },
    'broken-blueprints': { name: 'Broken Blueprints', stems: { vocals: { file: 'audio/10_BL_Instruments.mp3', label: 'Instruments' }, drums: { file: 'audio/10_BL_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/10_BL_Bass.mp3', label: 'Bass' }, other: { file: 'audio/10_BL_Other.mp3', label: 'Other' } } },
    'blurred-lines': { name: 'Blurred Lines (Interlude)', stems: { vocals: { file: 'audio/11_BLI_Sample.mp3', label: 'Sample' }, drums: { file: 'audio/11_BLI_Noise.mp3', label: 'Noise' }, bass: null, other: { file: 'audio/11_BLI_Other.mp3', label: 'Other' } } },
    'synthetic-dream': { name: 'Synthetic Dream', stems: { vocals: { file: 'audio/12_SF_Pads.mp3', label: 'Pads' }, drums: { file: 'audio/12_SF_Druma.mp3', label: 'Drums' }, bass: { file: 'audio/12_SF_Bass.mp3', label: 'Bass' }, other: { file: 'audio/12_SF_Arp.mp3', label: 'Arp' } } },
    'glass-walls': { name: 'Glass Walls (Outro)', stems: { vocals: { file: 'audio/13_GW_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/13_GW_Instruments.mp3', label: 'Instruments' }, bass: null, other: { file: 'audio/13_GW_Other.mp3', label: 'Other' } } }
  };

  const urlParams = new URLSearchParams(window.location.search);
  const trackId = urlParams.get('track') || 'godless-idols';
  const TRACK_CONFIG = TRACKS[trackId] || TRACKS['godless-idols'];

  document.getElementById('trackTitle').textContent = TRACK_CONFIG.name;
  document.title = `SIGNAL - ${TRACK_CONFIG.name}`;

  const stemPositions = { vocals: '.stem-control.top', drums: '.stem-control.right', bass: '.stem-control.bottom', other: '.stem-control.left' };

  Object.entries(stemPositions).forEach(([stem, selector]) => {
    const control = document.querySelector(selector);
    if (TRACK_CONFIG.stems[stem]) {
      control.style.visibility = 'visible';
      control.querySelector('.stem-label').textContent = TRACK_CONFIG.stems[stem].label;
    } else {
      control.style.visibility = 'hidden';
    }
  });

  new StemPlayer();
</script>

</body>
</html>