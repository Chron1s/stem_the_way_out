<!DOCTYPE html>
<html>
<head>
  <title>SIGNAL - Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }

    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    body {
      background: #0a0a0a;
      color: #fff;
      font-family: 'Space Mono', monospace;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      overflow: hidden;
    }

    /* Header */
    .header {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px 20px;
      border-bottom: 1px solid #1a1a1a;
      position: relative;
      flex-shrink: 0;
    }

    .back-btn {
      position: absolute;
      left: 15px;
      color: #555;
      font-size: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 6px 12px;
      border: 1px solid #333;
      border-radius: 15px;
      background: transparent;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      transition: all 0.2s ease;
    }

    .back-btn:hover {
      border-color: #666;
      color: #888;
    }

    .fullscreen-btn {
      position: absolute;
      right: 15px;
      color: #555;
      font-size: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 6px 12px;
      border: 1px solid #333;
      border-radius: 15px;
      background: transparent;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      transition: all 0.2s ease;
    }

    .fullscreen-btn:hover {
      border-color: #666;
      color: #888;
    }

    .track-title {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
    }

    /* Main Player Area - perfectly centered */
    .player-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
    }

    /* Stem Control Grid - symmetrical cross pattern */
    .stem-grid {
      display: grid;
      grid-template-columns: 100px 100px 100px;
      grid-template-rows: 100px 100px 100px;
      gap: 12px;
      align-items: center;
      justify-items: center;
    }

    .stem-control {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .stem-control.horizontal {
      flex-direction: row;
      gap: 12px;
    }

    .stem-control.top { grid-column: 2; grid-row: 1; }
    .stem-control.left { grid-column: 1; grid-row: 2; }
    .stem-control.center { grid-column: 2; grid-row: 2; }
    .stem-control.right { grid-column: 3; grid-row: 2; }
    .stem-control.bottom { grid-column: 2; grid-row: 3; }

    .stem-label {
      font-size: 8px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #555;
    }

    /* Light Bar Slider - no borders, no outlines */
    .light-bar {
      display: flex;
      gap: 5px;
      padding: 8px;
      background: transparent;
      border-radius: 20px;
      cursor: pointer;
      touch-action: none;
      border: none;
      outline: none;
    }

    .light-bar.horizontal {
      width: 90px;
      height: 34px;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      padding: 5px 10px;
    }

    .stem-control.left .light-bar.horizontal {
      flex-direction: row-reverse;
    }

    .light-bar.vertical {
      width: 34px;
      height: 90px;
      flex-direction: column-reverse;
      align-items: center;
      justify-content: center;
      padding: 10px 5px;
    }

    .stem-control.bottom .light-bar.vertical {
      flex-direction: column;
    }

    /* LED Orbs - refined texture with subtle depth */
    .led-segment {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2a2a2a 0%, #151515 60%, #0a0a0a 100%);
      flex-shrink: 0;
      box-shadow: none;
      border: none;
      outline: none;
    }

    .led-segment.active {
      opacity: 1;
    }

    .stem-control[data-stem="drums"] .led-segment.active {
      background: radial-gradient(circle at 35% 35%, #5dade2 0%, #2e86de 50%, #1a5276 100%);
    }

    .stem-control[data-stem="bass"] .led-segment.active {
      background: radial-gradient(circle at 35% 35%, #3498db 0%, #1a5276 50%, #0d2840 100%);
    }

    .stem-control[data-stem="other"] .led-segment.active {
      background: radial-gradient(circle at 35% 35%, #aed6f1 0%, #5dade2 50%, #2980b9 100%);
    }

    .stem-control[data-stem="vocals"] .led-segment.active {
      background: radial-gradient(circle at 35% 35%, #d4efff 0%, #85c1e9 50%, #5dade2 100%);
    }

    /* Play Button */
    .play-button {
      width: 58px;
      height: 58px;
      border-radius: 50%;
      background: #111;
      border: 2px solid #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .play-icon {
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 8px 0 8px 14px;
      border-color: transparent transparent transparent #fff;
      margin-left: 3px;
    }

    .play-button.playing .play-icon {
      border: none;
      width: 14px;
      height: 14px;
      margin-left: 0;
      background: linear-gradient(to right, #fff 0%, #fff 35%, transparent 35%, transparent 65%, #fff 65%, #fff 100%);
    }

    /* Progress Section - centered */
    .progress-section {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 0;
      flex-shrink: 0;
    }

    .time-row {
      width: 220px;
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .time-text {
      font-size: 10px;
      color: #555;
      font-family: 'Space Mono', monospace;
      min-width: 35px;
    }

    .time-text:last-child {
      text-align: right;
    }

    .progress-bar {
      width: 220px;
      height: 3px;
      background: #222;
      border-radius: 2px;
      cursor: pointer;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #85c1e9);
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s linear;
    }

    .skip-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 12px;
    }

    .skip-btn {
      width: 26px;
      height: 26px;
      background: transparent;
      border: 1px solid #333;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #555;
      transition: all 0.2s ease;
    }

    .skip-btn:hover {
      border-color: #666;
      color: #888;
    }

    .skip-btn svg {
      width: 10px;
      height: 10px;
      fill: currentColor;
    }

    .track-nav-btn {
      width: 26px;
      height: 26px;
      background: transparent;
      border: 1px solid #333;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #555;
      transition: all 0.2s ease;
      font-size: 10px;
    }

    .track-nav-btn:hover {
      border-color: #666;
      color: #888;
    }

    .track-nav-btn svg {
      width: 8px;
      height: 8px;
      fill: currentColor;
    }

    /* Loading */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .loading-overlay.hidden {
      display: none;
    }

    .loading-text {
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #555;
      margin-bottom: 15px;
    }

    .loading-bar {
      width: 150px;
      height: 2px;
      background: #222;
      overflow: hidden;
    }

    .loading-progress {
      height: 100%;
      background: #fff;
      width: 0%;
    }

    /* Safe areas for iPhone */
    @supports (padding-top: env(safe-area-inset-top)) {
      .header { padding-top: calc(15px + env(safe-area-inset-top)); }
      .progress-section { padding-bottom: calc(20px + env(safe-area-inset-bottom)); }
    }

    /* Help Modal */
    .help-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .help-overlay.visible {
      opacity: 1;
      pointer-events: all;
    }

    .help-modal {
      background: linear-gradient(145deg, #0a0a0a, #151515);
      border: 1px solid #222;
      border-radius: 20px;
      padding: 30px 35px;
      max-width: 340px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .help-overlay.visible .help-modal {
      transform: scale(1);
    }

    .help-title {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #fff;
      margin-bottom: 20px;
      text-align: center;
    }

    .help-section {
      margin-bottom: 20px;
    }

    .help-section-title {
      font-size: 9px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #3498db;
      margin-bottom: 10px;
    }

    .help-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #1a1a1a;
    }

    .help-item:last-child {
      border-bottom: none;
    }

    .help-action {
      font-size: 11px;
      color: #888;
    }

    .help-key {
      font-size: 10px;
      color: #555;
      background: #1a1a1a;
      padding: 4px 8px;
      border-radius: 4px;
      font-family: 'Space Mono', monospace;
    }

    .help-close {
      width: 100%;
      margin-top: 15px;
      padding: 12px;
      background: transparent;
      border: 1px solid #333;
      border-radius: 10px;
      color: #888;
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      transition: all 0.2s ease;
    }

    .help-close:hover {
      border-color: #3498db;
      color: #3498db;
    }

    .help-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: transparent;
      border: 1px solid #333;
      color: #555;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Space Mono', monospace;
      transition: all 0.2s ease;
      z-index: 50;
    }

    .help-btn:hover {
      border-color: #666;
      color: #888;
    }

    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .help-btn {
        bottom: calc(20px + env(safe-area-inset-bottom));
        right: calc(20px + env(safe-area-inset-right));
      }
    }

    /* Fullscreen styles */
    body.fullscreen .header,
    body.fullscreen .help-btn {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    body.fullscreen:hover .header,
    body.fullscreen:hover .help-btn {
      opacity: 1;
      pointer-events: all;
    }

    body.fullscreen .progress-section {
      opacity: 0.3;
      transition: opacity 0.3s ease;
    }

    body.fullscreen:hover .progress-section {
      opacity: 1;
    }
  </style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
  <div class="loading-text">Loading Stems</div>
  <div class="loading-bar">
    <div class="loading-progress" id="loadingProgress"></div>
  </div>
</div>

<div class="header">
  <button onclick="window.location.href='index.html#tracks'" class="back-btn">Tracks</button>
  <div class="track-title" id="trackTitle">Loading...</div>
  <button class="fullscreen-btn" id="fullscreenBtn">⛶</button>
</div>

<div class="player-container">
  <div class="stem-grid">
    <div class="stem-control top" data-stem="vocals">
      <span class="stem-label">Vocals</span>
      <div class="light-bar vertical">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
    </div>

    <div class="stem-control left horizontal" data-stem="other">
      <span class="stem-label">Other</span>
      <div class="light-bar horizontal">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
    </div>

    <div class="stem-control center">
      <div class="play-button" id="playButton">
        <div class="play-icon"></div>
      </div>
    </div>

    <div class="stem-control right horizontal" data-stem="drums">
      <div class="light-bar horizontal">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
      <span class="stem-label">Drums</span>
    </div>

    <div class="stem-control bottom" data-stem="bass">
      <div class="light-bar vertical">
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
        <div class="led-segment"></div>
      </div>
      <span class="stem-label">Bass</span>
    </div>
  </div>
</div>

<div class="progress-section">
  <div class="time-row">
    <span class="time-text" id="currentTime">0:00</span>
    <span class="time-text" id="totalTime">0:00</span>
  </div>
  <div class="progress-bar" id="progressBar">
    <div class="progress-fill" id="progressFill"></div>
  </div>
  <div class="skip-controls">
    <button class="track-nav-btn" id="prevTrack" title="Previous Track">
      <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
    </button>
    <button class="skip-btn" id="skipBack" title="Back 10s">
      <svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>
    </button>
    <button class="skip-btn" id="skipForward" title="Forward 10s">
      <svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
    </button>
    <button class="track-nav-btn" id="nextTrack" title="Next Track">
      <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zm2 0h2V6h-2v12z"/></svg>
    </button>
  </div>
</div>

<!-- Help Button -->
<button class="help-btn" id="helpBtn">?</button>

<!-- Help Modal -->
<div class="help-overlay" id="helpOverlay">
  <div class="help-modal">
    <div class="help-title">Controls</div>
    
    <div class="help-section">
      <div class="help-section-title" style="color: #e74c3c;">⚠️ No Sound?</div>
      <div class="help-item">
        <span class="help-action" style="color: #888;">Turn off Silent Mode on iPhone</span>
      </div>
    </div>
    
    <div class="help-section">
      <div class="help-section-title">Touch / Click</div>
      <div class="help-item">
        <span class="help-action">Tap stem orbs</span>
        <span class="help-key">Solo</span>
      </div>
      <div class="help-item">
        <span class="help-action">Drag stem orbs</span>
        <span class="help-key">Volume</span>
      </div>
      <div class="help-item">
        <span class="help-action">Tap play button</span>
        <span class="help-key">Play/Pause</span>
      </div>
    </div>
    
    <div class="help-section">
      <div class="help-section-title">Keyboard (Desktop)</div>
      <div class="help-item">
        <span class="help-action">Play / Pause</span>
        <span class="help-key">Space</span>
      </div>
      <div class="help-item">
        <span class="help-action">Skip ±10s</span>
        <span class="help-key">← →</span>
      </div>
      <div class="help-item">
        <span class="help-action">Prev / Next Track</span>
        <span class="help-key">↑ ↓</span>
      </div>
      <div class="help-item">
        <span class="help-action">Solo Vocals</span>
        <span class="help-key">1</span>
      </div>
      <div class="help-item">
        <span class="help-action">Solo Drums</span>
        <span class="help-key">2</span>
      </div>
      <div class="help-item">
        <span class="help-action">Solo Bass</span>
        <span class="help-key">3</span>
      </div>
      <div class="help-item">
        <span class="help-action">Solo Other</span>
        <span class="help-key">4</span>
      </div>
      <div class="help-item">
        <span class="help-action">Reset All Stems</span>
        <span class="help-key">0</span>
      </div>
      <div class="help-item">
        <span class="help-action">Fullscreen</span>
        <span class="help-key">F</span>
      </div>
    </div>
    
    <button class="help-close" id="helpClose">Got it</button>
  </div>
</div>

<audio id="silentAudio" src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAAYYoRwmHAAAAAAD/+1DEAAAGAAGn9AAAIwAANP8AAABM" loop playsinline></audio>

<script>
  // iOS Silent Mode Bypass - must be triggered by user interaction
  let audioUnlocked = false;
  
  function unlockAudio() {
    if (audioUnlocked) return;
    
    // Create and play a silent HTML5 audio to unlock audio playback
    const silentAudio = document.getElementById('silentAudio');
    silentAudio.volume = 0.01;
    const playPromise = silentAudio.play();
    if (playPromise) {
      playPromise.then(() => {
        silentAudio.pause();
        silentAudio.currentTime = 0;
      }).catch(() => {});
    }
    
    // Create AudioContext and play silent buffer
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      const ctx = new AudioContext();
      if (ctx.state === 'suspended') {
        ctx.resume();
      }
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      gainNode.gain.value = 0.001;
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      oscillator.start(0);
      oscillator.stop(0.001);
      ctx.close();
    }
    
    audioUnlocked = true;
  }

  // Attach to multiple events for better iOS coverage
  ['touchstart', 'touchend', 'click', 'keydown'].forEach(event => {
    document.addEventListener(event, unlockAudio, { once: false, passive: true });
  });

  // TRACKS must be defined first before being used
  const TRACKS = {
    'script': { name: 'Script (Intro)', stems: { vocals: { file: 'audio/01_SC_Instruments.mp3', label: 'Instruments' }, drums: { file: 'audio/01_SC_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/01_SC_Bass.mp3', label: 'Bass' }, other: { file: 'audio/01_SC_Other.mp3', label: 'Other' } } },
    'neon': { name: 'Neon', stems: { vocals: { file: 'audio/02_NE_Instruments.mp3', label: 'Instruments' }, drums: { file: 'audio/02_NE_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/02_NE_Bass.mp3', label: 'Bass' }, other: { file: 'audio/02_NE_Other.mp3', label: 'Other' } } },
    'smoke-show': { name: 'Smoke Show', stems: { vocals: { file: 'audio/03_SMS_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/03_SMS_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/03_SMS_Bass.mp3', label: 'Bass' }, other: { file: 'audio/03_SMS_Other.mp3', label: 'Other' } } },
    'godless-idols': { name: 'Godless Idols', stems: { vocals: { file: 'audio/GI_Voice.mp3', label: 'Voice' }, drums: { file: 'audio/GI_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/GI_Bass.mp3', label: 'Bass' }, other: { file: 'audio/GI_Other.mp3', label: 'Other' } } },
    'printer-brain': { name: 'Printer Brain', stems: { vocals: { file: 'audio/05_PB_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/05_PB_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/05_PB_Bass.mp3', label: 'Bass' }, other: { file: 'audio/05_PB_Other.mp3', label: 'Other' } } },
    'ash-and-gold': { name: 'Ash and Gold', stems: { vocals: { file: 'audio/06_AG_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/06_AG_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/06_AG_Instruments.mp3', label: 'Instruments' }, other: { file: 'audio/06_AG_Other.mp3', label: 'Other' } } },
    'production-line': { name: 'Production Line', stems: { vocals: { file: 'audio/07_PL_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/07_PL_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/07_PL_Bass.mp3', label: 'Bass' }, other: { file: 'audio/07_PL_Other.mp3', label: 'Other' } } },
    'byd3s1gn': { name: 'ByD3s1Gn', stems: { vocals: { file: 'audio/08_BD_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/08_BD_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/08_BD_Bass.mp3', label: 'Bass' }, other: { file: 'audio/08_BD_Instruments.mp3', label: 'Instruments' } } },
    'youre-meant-to-forget-this': { name: "You're Meant to Forget This", stems: { vocals: { file: 'audio/09_YAMTFT_Instrument.mp3', label: 'Instrument' }, drums: { file: 'audio/09_YAMTFT_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/09_YAMTFT_Bass.mp3', label: 'Bass' }, other: null } },
    'broken-blueprints': { name: 'Broken Blueprints', stems: { vocals: { file: 'audio/10_BL_Instruments.mp3', label: 'Instruments' }, drums: { file: 'audio/10_BL_Drums.mp3', label: 'Drums' }, bass: { file: 'audio/10_BL_Bass.mp3', label: 'Bass' }, other: { file: 'audio/10_BL_Other.mp3', label: 'Other' } } },
    'blurred-lines': { name: 'Blurred Lines (Interlude)', stems: { vocals: { file: 'audio/11_BLI_Sample.mp3', label: 'Sample' }, drums: { file: 'audio/11_BLI_Noise.mp3', label: 'Noise' }, bass: null, other: { file: 'audio/11_BLI_Other.mp3', label: 'Other' } } },
    'synthetic-dream': { name: 'Synthetic Dream', stems: { vocals: { file: 'audio/12_SF_Pads.mp3', label: 'Pads' }, drums: { file: 'audio/12_SF_Druma.mp3', label: 'Drums' }, bass: { file: 'audio/12_SF_Bass.mp3', label: 'Bass' }, other: { file: 'audio/12_SF_Arp.mp3', label: 'Arp' } } },
    'glass-walls': { name: 'Glass Walls (Outro)', stems: { vocals: { file: 'audio/13_GW_Vocals.mp3', label: 'Vocals' }, drums: { file: 'audio/13_GW_Instruments.mp3', label: 'Instruments' }, bass: null, other: { file: 'audio/13_GW_Other.mp3', label: 'Other' } } }
  };

  // Track list for navigation
  const TRACK_ORDER = [
    'script', 'neon', 'smoke-show', 'godless-idols', 'printer-brain',
    'ash-and-gold', 'production-line', 'byd3s1gn', 'youre-meant-to-forget-this',
    'broken-blueprints', 'blurred-lines', 'synthetic-dream', 'glass-walls'
  ];

  const urlParams = new URLSearchParams(window.location.search);
  const trackId = urlParams.get('track') || 'godless-idols';
  const TRACK_CONFIG = TRACKS[trackId] || TRACKS['godless-idols'];
  const currentTrackIndex = TRACK_ORDER.indexOf(trackId);

  // Navigate to previous/next track
  function goToTrack(direction) {
    let newIndex = currentTrackIndex + direction;
    if (newIndex < 0) newIndex = TRACK_ORDER.length - 1;
    if (newIndex >= TRACK_ORDER.length) newIndex = 0;
    // Save current position before leaving
    savePosition();
    window.location.href = `player.html?track=${TRACK_ORDER[newIndex]}`;
  }

  // Save position to localStorage
  function savePosition() {
    if (window.player && window.player.duration > 0) {
      const position = window.player.getCurrentTime();
      localStorage.setItem(`signal_position_${trackId}`, position.toString());
    }
  }

  // Load saved position
  function loadPosition() {
    const saved = localStorage.getItem(`signal_position_${trackId}`);
    return saved ? parseFloat(saved) : 0;
  }

  // Save position periodically and on page unload
  setInterval(savePosition, 5000);
  window.addEventListener('beforeunload', savePosition);
  window.addEventListener('pagehide', savePosition);

  document.getElementById('trackTitle').textContent = TRACK_CONFIG.name;
  document.title = `SIGNAL - ${TRACK_CONFIG.name}`;

  class StemPlayer {
    constructor() {
      this.audioContext = null;
      this.isPlaying = false;
      this.startTime = 0;
      this.pauseTime = 0;
      this.duration = 0;
      this.stems = {
        vocals: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastRms: 0, smoothedRms: 0 },
        drums: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastRms: 0, smoothedRms: 0 },
        bass: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastRms: 0, smoothedRms: 0 },
        other: { buffer: null, source: null, gainNode: null, volume: 100, analyser: null, lastRms: 0, smoothedRms: 0 }
      };
      this.masterGain = null;
      this.loadingProgress = document.getElementById('loadingProgress');
      this.loadingOverlay = document.getElementById('loadingOverlay');
      this.progressBar = document.getElementById('progressBar');
      this.progressFill = document.getElementById('progressFill');
      this.currentTimeEl = document.getElementById('currentTime');
      this.totalTimeEl = document.getElementById('totalTime');
      this.init();
    }

    initAudioContext() {
      if (this.audioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      this.audioContext = new AudioContext();
      this.masterGain = this.audioContext.createGain();
      this.masterGain.connect(this.audioContext.destination);
      if (this.audioContext.state === 'suspended') this.audioContext.resume();
    }

    async init() {
      try {
        this.initAudioContext();
        await this.loadStems();
        this.setupUI();
        this.setupProgressBar();
        this.setupSkipControls();
        Object.keys(this.stems).forEach(stem => updateLightBar(stem, 100));
        for (const stem of Object.values(this.stems)) {
          if (stem.buffer) {
            this.duration = stem.buffer.duration;
            this.totalTimeEl.textContent = this.formatTime(this.duration);
            break;
          }
        }
        this.updateProgress();
        this.loadingOverlay.classList.add('hidden');
      } catch (e) {
        console.log('Waiting for user interaction');
      }
    }

    async loadStems() {
      if (!this.audioContext) return;
      const stemsToLoad = Object.entries(TRACK_CONFIG.stems).filter(([_, stem]) => stem !== null);
      const totalStems = stemsToLoad.length;
      let loaded = 0;

      // Load stems sequentially to ensure sync
      for (const [stemName, stemData] of stemsToLoad) {
        if (stemData && stemData.file) {
          try {
            const response = await fetch(stemData.file);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            const gainNode = this.audioContext.createGain();
            const analyser = this.audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.3;
            gainNode.connect(analyser);
            analyser.connect(this.masterGain);
            this.stems[stemName].buffer = audioBuffer;
            this.stems[stemName].gainNode = gainNode;
            this.stems[stemName].analyser = analyser;
            loaded++;
            this.loadingProgress.style.width = (loaded / totalStems * 100) + '%';
          } catch (error) {
            console.error(`Failed to load ${stemName}:`, error);
          }
        }
      }
    }

    setupUI() {
      document.getElementById('playButton').addEventListener('click', () => {
        unlockAudio();
        this.initAudioContext();
        if (this.audioContext.state === 'suspended') this.audioContext.resume();
        this.togglePlay();
      });

      document.querySelectorAll('.stem-control[data-stem]').forEach(control => {
        const stemName = control.dataset.stem;
        const slider = control.querySelector('.light-bar');
        const isHorizontal = slider.classList.contains('horizontal');
        const isLeftSlider = control.classList.contains('left');
        let isDragging = false;
        let dragStarted = false;

        const updateVolume = (percent) => {
          percent = Math.max(0, Math.min(100, percent));
          this.stems[stemName].volume = percent;
          updateLightBar(stemName, percent);
          if (this.stems[stemName].gainNode) {
            this.stems[stemName].gainNode.gain.setTargetAtTime(percent / 100, this.audioContext.currentTime, 0.02);
          }
        };

        const handleMove = (clientX, clientY) => {
          const rect = slider.getBoundingClientRect();
          let percent;
          if (isHorizontal) {
            percent = isLeftSlider ? 100 - ((clientX - rect.left) / rect.width) * 100 : ((clientX - rect.left) / rect.width) * 100;
          } else {
            const isBottomSlider = control.classList.contains('bottom');
            percent = isBottomSlider ? ((clientY - rect.top) / rect.height) * 100 : 100 - ((clientY - rect.top) / rect.height) * 100;
          }
          updateVolume(percent);
        };

        const soloStem = () => {
          const allMuted = Object.entries(this.stems).filter(([n]) => n !== stemName).every(([, s]) => s.volume === 0);
          const thisFull = this.stems[stemName].volume === 100;
          if (allMuted && thisFull) {
            Object.keys(this.stems).forEach(name => {
              this.stems[name].volume = 100;
              if (this.stems[name].gainNode) this.stems[name].gainNode.gain.setTargetAtTime(1, this.audioContext.currentTime, 0.02);
              updateLightBar(name, 100);
            });
          } else {
            Object.keys(this.stems).forEach(name => {
              const vol = name === stemName ? 100 : 0;
              this.stems[name].volume = vol;
              if (this.stems[name].gainNode) this.stems[name].gainNode.gain.setTargetAtTime(vol / 100, this.audioContext.currentTime, 0.02);
              updateLightBar(name, vol);
            });
          }
        };

        slider.addEventListener('mousedown', (e) => { e.preventDefault(); isDragging = true; dragStarted = false; });
        document.addEventListener('mousemove', (e) => { if (isDragging) { dragStarted = true; handleMove(e.clientX, e.clientY); } });
        document.addEventListener('mouseup', () => { if (isDragging && !dragStarted) soloStem(); isDragging = false; });
        slider.addEventListener('touchstart', (e) => { e.preventDefault(); isDragging = true; dragStarted = false; }, { passive: false });
        slider.addEventListener('touchmove', (e) => { if (isDragging) { dragStarted = true; handleMove(e.touches[0].clientX, e.touches[0].clientY); } }, { passive: false });
        slider.addEventListener('touchend', () => { if (isDragging && !dragStarted) soloStem(); isDragging = false; });
      });

      // Setup track navigation buttons
      document.getElementById('prevTrack').addEventListener('click', () => goToTrack(-1));
      document.getElementById('nextTrack').addEventListener('click', () => goToTrack(1));

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (!window.player) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            window.player.togglePlay();
            break;
          case 'ArrowLeft':
            e.preventDefault();
            window.player.seekTo(Math.max(0, window.player.getCurrentTime() - 10));
            break;
          case 'ArrowRight':
            e.preventDefault();
            window.player.seekTo(Math.min(window.player.duration, window.player.getCurrentTime() + 10));
            break;
          case 'ArrowUp':
            e.preventDefault();
            goToTrack(-1);
            break;
          case 'ArrowDown':
            e.preventDefault();
            goToTrack(1);
            break;
          case 'Digit1':
          case 'Numpad1':
            e.preventDefault();
            soloStemByKey('vocals');
            break;
          case 'Digit2':
          case 'Numpad2':
            e.preventDefault();
            soloStemByKey('drums');
            break;
          case 'Digit3':
          case 'Numpad3':
            e.preventDefault();
            soloStemByKey('bass');
            break;
          case 'Digit4':
          case 'Numpad4':
            e.preventDefault();
            soloStemByKey('other');
            break;
          case 'Digit0':
          case 'Numpad0':
            e.preventDefault();
            // Reset all stems to 100%
            Object.keys(window.player.stems).forEach(name => {
              window.player.stems[name].volume = 100;
              if (window.player.stems[name].gainNode) {
                window.player.stems[name].gainNode.gain.setTargetAtTime(1, window.player.audioContext.currentTime, 0.02);
              }
              updateLightBar(name, 100);
            });
            break;
        }
      });
    }

    setupProgressBar() {
      let isDragging = false;
      const seek = (clientX) => {
        const rect = this.progressBar.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        this.seekTo(percent * this.duration);
      };
      this.progressBar.addEventListener('mousedown', (e) => { isDragging = true; seek(e.clientX); });
      document.addEventListener('mousemove', (e) => { if (isDragging) seek(e.clientX); });
      document.addEventListener('mouseup', () => { isDragging = false; });
      this.progressBar.addEventListener('touchstart', (e) => { isDragging = true; seek(e.touches[0].clientX); }, { passive: true });
      this.progressBar.addEventListener('touchmove', (e) => { if (isDragging) seek(e.touches[0].clientX); }, { passive: true });
      this.progressBar.addEventListener('touchend', () => { isDragging = false; });
    }

    setupSkipControls() {
      document.getElementById('skipBack').addEventListener('click', () => this.seekTo(Math.max(0, this.getCurrentTime() - 10)));
      document.getElementById('skipForward').addEventListener('click', () => this.seekTo(Math.min(this.duration, this.getCurrentTime() + 10)));
    }

    getCurrentTime() {
      if (!this.audioContext) return 0;
      return this.isPlaying ? this.audioContext.currentTime - this.startTime : this.pauseTime;
    }

    seekTo(time) {
      if (!this.audioContext) return;
      time = Math.max(0, Math.min(time, this.duration));
      if (this.isPlaying) {
        Object.values(this.stems).forEach(stem => { if (stem.source) { stem.source.stop(); stem.source = null; } });
        this.startTime = this.audioContext.currentTime - time;
        Object.entries(this.stems).forEach(([_, stem]) => {
          if (stem.buffer) {
            const source = this.audioContext.createBufferSource();
            source.buffer = stem.buffer;
            source.connect(stem.gainNode);
            source.start(0, time);
            stem.source = source;
          }
        });
      } else {
        this.pauseTime = time;
      }
      this.progressFill.style.width = (time / this.duration) * 100 + '%';
      this.currentTimeEl.textContent = this.formatTime(time);
    }

    togglePlay() { if (this.isPlaying) this.pause(); else this.play(); }

    play() {
      if (this.isPlaying || !this.audioContext) return;
      if (this.audioContext.state === 'suspended') this.audioContext.resume();
      const offset = this.pauseTime;
      this.startTime = this.audioContext.currentTime - offset;
      Object.entries(this.stems).forEach(([_, stem]) => {
        if (stem.buffer) {
          const source = this.audioContext.createBufferSource();
          source.buffer = stem.buffer;
          source.connect(stem.gainNode);
          source.start(0, offset);
          stem.source = source;
          stem.gainNode.gain.value = stem.volume / 100;
        }
      });
      this.isPlaying = true;
      document.getElementById('playButton').classList.add('playing');
    }

    pause() {
      if (!this.isPlaying) return;
      this.pauseTime = this.audioContext.currentTime - this.startTime;
      Object.values(this.stems).forEach(stem => { if (stem.source) { stem.source.stop(); stem.source = null; } });
      this.isPlaying = false;
      document.getElementById('playButton').classList.remove('playing');
    }

    stop() {
      this.pause();
      this.pauseTime = 0;
      this.progressFill.style.width = '0%';
      this.currentTimeEl.textContent = '0:00';
    }

    updateProgress() {
      const update = () => {
        if (this.isPlaying && this.audioContext) {
          const currentTime = this.getCurrentTime();
          this.progressFill.style.width = Math.min((currentTime / this.duration) * 100, 100) + '%';
          this.currentTimeEl.textContent = this.formatTime(currentTime);
          if (currentTime >= this.duration) this.stop();
          this.updateRhythmicPulse();
        }
        requestAnimationFrame(update);
      };
      update();
    }

    updateRhythmicPulse() {
      Object.entries(this.stems).forEach(([stemName, stem]) => {
        if (stem.analyser && stem.volume > 0 && stem.buffer) {
          const dataArray = new Uint8Array(stem.analyser.frequencyBinCount);
          stem.analyser.getByteFrequencyData(dataArray);
          
          // Calculate RMS energy
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i] * dataArray[i];
          }
          const rms = Math.sqrt(sum / dataArray.length);
          
          // Normalize to 0-1 range (max RMS is around 180)
          const normalizedLevel = Math.min(rms / 80, 1);
          
          // Map to opacity: 0.3 (quiet) to 1.0 (loud)
          const opacity = 0.3 + (normalizedLevel * 0.7);
          
          // Apply directly to LED segments for real-time reactivity
          const control = document.querySelector(`.stem-control[data-stem="${stemName}"]`);
          if (control) {
            const segments = control.querySelectorAll('.led-segment.active');
            segments.forEach(seg => {
              seg.style.opacity = opacity.toFixed(2);
            });
          }
        }
      });
    }

    formatTime(seconds) {
      if (!seconds || isNaN(seconds) || !isFinite(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
  }

  function updateLightBar(stemName, volume) {
    const control = document.querySelector(`.stem-control[data-stem="${stemName}"]`);
    if (!control) return;
    const segments = control.querySelectorAll('.led-segment');
    const activeCount = Math.round((volume / 100) * segments.length);
    segments.forEach((seg, i) => {
      if (i < activeCount) seg.classList.add('active');
      else seg.classList.remove('active');
    });
  }

  function soloStemByKey(stemName) {
    if (!window.player || !window.player.stems[stemName].buffer) return;
    const allMuted = Object.entries(window.player.stems)
      .filter(([n]) => n !== stemName)
      .every(([, s]) => s.volume === 0);
    const thisFull = window.player.stems[stemName].volume === 100;
    
    if (allMuted && thisFull) {
      // Restore all
      Object.keys(window.player.stems).forEach(name => {
        window.player.stems[name].volume = 100;
        if (window.player.stems[name].gainNode) {
          window.player.stems[name].gainNode.gain.setTargetAtTime(1, window.player.audioContext.currentTime, 0.02);
        }
        updateLightBar(name, 100);
      });
    } else {
      // Solo this stem
      Object.keys(window.player.stems).forEach(name => {
        const vol = name === stemName ? 100 : 0;
        window.player.stems[name].volume = vol;
        if (window.player.stems[name].gainNode) {
          window.player.stems[name].gainNode.gain.setTargetAtTime(vol / 100, window.player.audioContext.currentTime, 0.02);
        }
        updateLightBar(name, vol);
      });
    }
  }

  const stemPositions = { vocals: '.stem-control.top', drums: '.stem-control.right', bass: '.stem-control.bottom', other: '.stem-control.left' };

  Object.entries(stemPositions).forEach(([stem, selector]) => {
    const control = document.querySelector(selector);
    if (TRACK_CONFIG.stems[stem]) {
      control.style.visibility = 'visible';
      control.querySelector('.stem-label').textContent = TRACK_CONFIG.stems[stem].label;
    } else {
      control.style.visibility = 'hidden';
    }
  });

  // Create player and restore position
  const player = new StemPlayer();
  window.player = player;
  
  // Restore saved position after a short delay
  setTimeout(() => {
    const savedPosition = loadPosition();
    if (savedPosition > 0 && savedPosition < player.duration - 1) {
      player.seekTo(savedPosition);
    }
  }, 500);

  // Help Modal
  const helpOverlay = document.getElementById('helpOverlay');
  const helpBtn = document.getElementById('helpBtn');
  const helpClose = document.getElementById('helpClose');

  function showHelp() {
    helpOverlay.classList.add('visible');
  }

  function hideHelp() {
    helpOverlay.classList.remove('visible');
    localStorage.setItem('signal_help_seen', 'true');
  }

  helpBtn.addEventListener('click', showHelp);
  helpClose.addEventListener('click', hideHelp);
  helpOverlay.addEventListener('click', (e) => {
    if (e.target === helpOverlay) hideHelp();
  });

  // Show help on first visit
  if (!localStorage.getItem('signal_help_seen')) {
    setTimeout(showHelp, 1000);
  }

  // Fullscreen
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  
  // Check if fullscreen is supported
  const fullscreenSupported = document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen;
  
  // Detect iOS
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

  function toggleFullscreen() {
    // iOS doesn't support fullscreen API - show tip instead
    if (isIOS) {
      alert('To go fullscreen on iPhone:\n\n1. Tap the Share button\n2. Select "Add to Home Screen"\n3. Open from your home screen');
      return;
    }
    
    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen().catch(err => {
          console.log('Fullscreen error:', err);
        });
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      }
      document.body.classList.add('fullscreen');
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
      document.body.classList.remove('fullscreen');
    }
  }

  fullscreenBtn.addEventListener('click', toggleFullscreen);

  // Add F key for fullscreen
  document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyF' && !e.ctrlKey && !e.metaKey) {
      e.preventDefault();
      toggleFullscreen();
    }
    if (e.code === 'Escape' && helpOverlay.classList.contains('visible')) {
      hideHelp();
    }
  });

  // Update fullscreen state on change
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      document.body.classList.remove('fullscreen');
    }
  });
  document.addEventListener('webkitfullscreenchange', () => {
    if (!document.webkitFullscreenElement) {
      document.body.classList.remove('fullscreen');
    }
  });
</script>

</body>
</html>